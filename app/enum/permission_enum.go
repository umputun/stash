// Code generated by enum generator; DO NOT EDIT.
package enum

import (
	"fmt"
	"strings"
)

// Permission is the exported type for the enum
type Permission struct {
	name  string
	value int
}

func (e Permission) String() string { return e.name }

// Index returns the underlying integer value
func (e Permission) Index() int { return e.value }

// MarshalText implements encoding.TextMarshaler
func (e Permission) MarshalText() ([]byte, error) {
	return []byte(e.name), nil
}

// UnmarshalText implements encoding.TextUnmarshaler
func (e *Permission) UnmarshalText(text []byte) error {
	var err error
	*e, err = ParsePermission(string(text))
	return err
}

// _permissionParseMap is used for efficient string to enum conversion
var _permissionParseMap = map[string]Permission{
	"none":       PermissionNone,
	"read":       PermissionRead,
	"r":          PermissionRead,
	"write":      PermissionWrite,
	"w":          PermissionWrite,
	"readwrite":  PermissionReadWrite,
	"rw":         PermissionReadWrite,
	"read-write": PermissionReadWrite,
}

// ParsePermission converts string to permission enum value.
// Parsing is always case-insensitive.
func ParsePermission(v string) (Permission, error) {
	if val, ok := _permissionParseMap[strings.ToLower(v)]; ok {
		return val, nil
	}
	return Permission{}, fmt.Errorf("invalid permission: %s", v)
}

// MustPermission is like ParsePermission but panics if string is invalid
func MustPermission(v string) Permission {
	r, err := ParsePermission(v)
	if err != nil {
		panic(err)
	}
	return r
}

// Public constants for permission values
var (
	PermissionNone      = Permission{name: "none", value: 0}
	PermissionRead      = Permission{name: "read", value: 1}
	PermissionWrite     = Permission{name: "write", value: 2}
	PermissionReadWrite = Permission{name: "readwrite", value: 3}
)

// PermissionValues contains all possible enum values
var PermissionValues = []Permission{
	PermissionNone,
	PermissionRead,
	PermissionWrite,
	PermissionReadWrite,
}

// PermissionNames contains all possible enum names
var PermissionNames = []string{
	"none",
	"read",
	"write",
	"readwrite",
}

// PermissionIter returns a function compatible with Go 1.23's range-over-func syntax.
// It yields all Permission values in declaration order. Example:
//
//	for v := range PermissionIter() {
//	    // use v
//	}
func PermissionIter() func(yield func(Permission) bool) {
	return func(yield func(Permission) bool) {
		for _, v := range PermissionValues {
			if !yield(v) {
				break
			}
		}
	}
}

// These variables are used to prevent the compiler from reporting unused errors
// for the original enum constants. They are intentionally placed in a var block
// that is compiled away by the Go compiler.
var _ = func() bool {
	var _ permission = permission(0)
	// This avoids "defined but not used" linter error for permissionNone
	var _ permission = permissionNone
	// This avoids "defined but not used" linter error for permissionRead
	var _ permission = permissionRead
	// This avoids "defined but not used" linter error for permissionWrite
	var _ permission = permissionWrite
	// This avoids "defined but not used" linter error for permissionReadWrite
	var _ permission = permissionReadWrite
	return true
}()
