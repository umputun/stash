// Code generated by enum generator; DO NOT EDIT.
package enum

import (
	"fmt"
	"strings"
)

// Format is the exported type for the enum
type Format struct {
	name  string
	value int
}

func (e Format) String() string { return e.name }

// Index returns the underlying integer value
func (e Format) Index() int { return e.value }

// MarshalText implements encoding.TextMarshaler
func (e Format) MarshalText() ([]byte, error) {
	return []byte(e.name), nil
}

// UnmarshalText implements encoding.TextUnmarshaler
func (e *Format) UnmarshalText(text []byte) error {
	var err error
	*e, err = ParseFormat(string(text))
	return err
}

// _formatParseMap is used for efficient string to enum conversion
var _formatParseMap = map[string]Format{
	"text":  FormatText,
	"json":  FormatJSON,
	"yaml":  FormatYAML,
	"xml":   FormatXML,
	"toml":  FormatTOML,
	"ini":   FormatINI,
	"hcl":   FormatHCL,
	"shell": FormatShell,
}

// ParseFormat converts string to format enum value.
// Parsing is always case-insensitive.
func ParseFormat(v string) (Format, error) {
	if val, ok := _formatParseMap[strings.ToLower(v)]; ok {
		return val, nil
	}
	return Format{}, fmt.Errorf("invalid format: %s", v)
}

// MustFormat is like ParseFormat but panics if string is invalid
func MustFormat(v string) Format {
	r, err := ParseFormat(v)
	if err != nil {
		panic(err)
	}
	return r
}

// Public constants for format values
var (
	FormatText  = Format{name: "text", value: 0}
	FormatJSON  = Format{name: "json", value: 1}
	FormatYAML  = Format{name: "yaml", value: 2}
	FormatXML   = Format{name: "xml", value: 3}
	FormatTOML  = Format{name: "toml", value: 4}
	FormatINI   = Format{name: "ini", value: 5}
	FormatHCL   = Format{name: "hcl", value: 6}
	FormatShell = Format{name: "shell", value: 7}
)

// FormatValues contains all possible enum values
var FormatValues = []Format{
	FormatText,
	FormatJSON,
	FormatYAML,
	FormatXML,
	FormatTOML,
	FormatINI,
	FormatHCL,
	FormatShell,
}

// FormatNames contains all possible enum names
var FormatNames = []string{
	"text",
	"json",
	"yaml",
	"xml",
	"toml",
	"ini",
	"hcl",
	"shell",
}

// FormatIter returns a function compatible with Go 1.23's range-over-func syntax.
// It yields all Format values in declaration order. Example:
//
//	for v := range FormatIter() {
//	    // use v
//	}
func FormatIter() func(yield func(Format) bool) {
	return func(yield func(Format) bool) {
		for _, v := range FormatValues {
			if !yield(v) {
				break
			}
		}
	}
}

// These variables are used to prevent the compiler from reporting unused errors
// for the original enum constants. They are intentionally placed in a var block
// that is compiled away by the Go compiler.
var _ = func() bool {
	var _ format = format(0)
	// This avoids "defined but not used" linter error for formatText
	var _ format = formatText
	// This avoids "defined but not used" linter error for formatJSON
	var _ format = formatJSON
	// This avoids "defined but not used" linter error for formatYAML
	var _ format = formatYAML
	// This avoids "defined but not used" linter error for formatXML
	var _ format = formatXML
	// This avoids "defined but not used" linter error for formatTOML
	var _ format = formatTOML
	// This avoids "defined but not used" linter error for formatINI
	var _ format = formatINI
	// This avoids "defined but not used" linter error for formatHCL
	var _ format = formatHCL
	// This avoids "defined but not used" linter error for formatShell
	var _ format = formatShell
	return true
}()
