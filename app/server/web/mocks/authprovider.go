// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"
	"time"
)

// AuthProviderMock is a mock implementation of web.AuthProvider.
//
//	func TestSomethingThatUsesAuthProvider(t *testing.T) {
//
//		// make and configure a mocked web.AuthProvider
//		mockedAuthProvider := &AuthProviderMock{
//			CheckUserPermissionFunc: func(username string, key string, write bool) bool {
//				panic("mock out the CheckUserPermission method")
//			},
//			CreateSessionFunc: func(ctx context.Context, username string) (string, error) {
//				panic("mock out the CreateSession method")
//			},
//			EnabledFunc: func() bool {
//				panic("mock out the Enabled method")
//			},
//			FilterUserKeysFunc: func(username string, keys []string) []string {
//				panic("mock out the FilterUserKeys method")
//			},
//			GetSessionUserFunc: func(ctx context.Context, token string) (string, bool) {
//				panic("mock out the GetSessionUser method")
//			},
//			InvalidateSessionFunc: func(ctx context.Context, token string)  {
//				panic("mock out the InvalidateSession method")
//			},
//			IsValidUserFunc: func(username string, password string) bool {
//				panic("mock out the IsValidUser method")
//			},
//			LoginTTLFunc: func() time.Duration {
//				panic("mock out the LoginTTL method")
//			},
//			UserCanWriteFunc: func(username string) bool {
//				panic("mock out the UserCanWrite method")
//			},
//		}
//
//		// use mockedAuthProvider in code that requires web.AuthProvider
//		// and then make assertions.
//
//	}
type AuthProviderMock struct {
	// CheckUserPermissionFunc mocks the CheckUserPermission method.
	CheckUserPermissionFunc func(username string, key string, write bool) bool

	// CreateSessionFunc mocks the CreateSession method.
	CreateSessionFunc func(ctx context.Context, username string) (string, error)

	// EnabledFunc mocks the Enabled method.
	EnabledFunc func() bool

	// FilterUserKeysFunc mocks the FilterUserKeys method.
	FilterUserKeysFunc func(username string, keys []string) []string

	// GetSessionUserFunc mocks the GetSessionUser method.
	GetSessionUserFunc func(ctx context.Context, token string) (string, bool)

	// InvalidateSessionFunc mocks the InvalidateSession method.
	InvalidateSessionFunc func(ctx context.Context, token string)

	// IsValidUserFunc mocks the IsValidUser method.
	IsValidUserFunc func(username string, password string) bool

	// LoginTTLFunc mocks the LoginTTL method.
	LoginTTLFunc func() time.Duration

	// UserCanWriteFunc mocks the UserCanWrite method.
	UserCanWriteFunc func(username string) bool

	// calls tracks calls to the methods.
	calls struct {
		// CheckUserPermission holds details about calls to the CheckUserPermission method.
		CheckUserPermission []struct {
			// Username is the username argument value.
			Username string
			// Key is the key argument value.
			Key string
			// Write is the write argument value.
			Write bool
		}
		// CreateSession holds details about calls to the CreateSession method.
		CreateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
		}
		// Enabled holds details about calls to the Enabled method.
		Enabled []struct {
		}
		// FilterUserKeys holds details about calls to the FilterUserKeys method.
		FilterUserKeys []struct {
			// Username is the username argument value.
			Username string
			// Keys is the keys argument value.
			Keys []string
		}
		// GetSessionUser holds details about calls to the GetSessionUser method.
		GetSessionUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
		// InvalidateSession holds details about calls to the InvalidateSession method.
		InvalidateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
		// IsValidUser holds details about calls to the IsValidUser method.
		IsValidUser []struct {
			// Username is the username argument value.
			Username string
			// Password is the password argument value.
			Password string
		}
		// LoginTTL holds details about calls to the LoginTTL method.
		LoginTTL []struct {
		}
		// UserCanWrite holds details about calls to the UserCanWrite method.
		UserCanWrite []struct {
			// Username is the username argument value.
			Username string
		}
	}
	lockCheckUserPermission sync.RWMutex
	lockCreateSession       sync.RWMutex
	lockEnabled             sync.RWMutex
	lockFilterUserKeys      sync.RWMutex
	lockGetSessionUser      sync.RWMutex
	lockInvalidateSession   sync.RWMutex
	lockIsValidUser         sync.RWMutex
	lockLoginTTL            sync.RWMutex
	lockUserCanWrite        sync.RWMutex
}

// CheckUserPermission calls CheckUserPermissionFunc.
func (mock *AuthProviderMock) CheckUserPermission(username string, key string, write bool) bool {
	if mock.CheckUserPermissionFunc == nil {
		panic("AuthProviderMock.CheckUserPermissionFunc: method is nil but AuthProvider.CheckUserPermission was just called")
	}
	callInfo := struct {
		Username string
		Key      string
		Write    bool
	}{
		Username: username,
		Key:      key,
		Write:    write,
	}
	mock.lockCheckUserPermission.Lock()
	mock.calls.CheckUserPermission = append(mock.calls.CheckUserPermission, callInfo)
	mock.lockCheckUserPermission.Unlock()
	return mock.CheckUserPermissionFunc(username, key, write)
}

// CheckUserPermissionCalls gets all the calls that were made to CheckUserPermission.
// Check the length with:
//
//	len(mockedAuthProvider.CheckUserPermissionCalls())
func (mock *AuthProviderMock) CheckUserPermissionCalls() []struct {
	Username string
	Key      string
	Write    bool
} {
	var calls []struct {
		Username string
		Key      string
		Write    bool
	}
	mock.lockCheckUserPermission.RLock()
	calls = mock.calls.CheckUserPermission
	mock.lockCheckUserPermission.RUnlock()
	return calls
}

// CreateSession calls CreateSessionFunc.
func (mock *AuthProviderMock) CreateSession(ctx context.Context, username string) (string, error) {
	if mock.CreateSessionFunc == nil {
		panic("AuthProviderMock.CreateSessionFunc: method is nil but AuthProvider.CreateSession was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
	}{
		Ctx:      ctx,
		Username: username,
	}
	mock.lockCreateSession.Lock()
	mock.calls.CreateSession = append(mock.calls.CreateSession, callInfo)
	mock.lockCreateSession.Unlock()
	return mock.CreateSessionFunc(ctx, username)
}

// CreateSessionCalls gets all the calls that were made to CreateSession.
// Check the length with:
//
//	len(mockedAuthProvider.CreateSessionCalls())
func (mock *AuthProviderMock) CreateSessionCalls() []struct {
	Ctx      context.Context
	Username string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
	}
	mock.lockCreateSession.RLock()
	calls = mock.calls.CreateSession
	mock.lockCreateSession.RUnlock()
	return calls
}

// Enabled calls EnabledFunc.
func (mock *AuthProviderMock) Enabled() bool {
	if mock.EnabledFunc == nil {
		panic("AuthProviderMock.EnabledFunc: method is nil but AuthProvider.Enabled was just called")
	}
	callInfo := struct {
	}{}
	mock.lockEnabled.Lock()
	mock.calls.Enabled = append(mock.calls.Enabled, callInfo)
	mock.lockEnabled.Unlock()
	return mock.EnabledFunc()
}

// EnabledCalls gets all the calls that were made to Enabled.
// Check the length with:
//
//	len(mockedAuthProvider.EnabledCalls())
func (mock *AuthProviderMock) EnabledCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEnabled.RLock()
	calls = mock.calls.Enabled
	mock.lockEnabled.RUnlock()
	return calls
}

// FilterUserKeys calls FilterUserKeysFunc.
func (mock *AuthProviderMock) FilterUserKeys(username string, keys []string) []string {
	if mock.FilterUserKeysFunc == nil {
		panic("AuthProviderMock.FilterUserKeysFunc: method is nil but AuthProvider.FilterUserKeys was just called")
	}
	callInfo := struct {
		Username string
		Keys     []string
	}{
		Username: username,
		Keys:     keys,
	}
	mock.lockFilterUserKeys.Lock()
	mock.calls.FilterUserKeys = append(mock.calls.FilterUserKeys, callInfo)
	mock.lockFilterUserKeys.Unlock()
	return mock.FilterUserKeysFunc(username, keys)
}

// FilterUserKeysCalls gets all the calls that were made to FilterUserKeys.
// Check the length with:
//
//	len(mockedAuthProvider.FilterUserKeysCalls())
func (mock *AuthProviderMock) FilterUserKeysCalls() []struct {
	Username string
	Keys     []string
} {
	var calls []struct {
		Username string
		Keys     []string
	}
	mock.lockFilterUserKeys.RLock()
	calls = mock.calls.FilterUserKeys
	mock.lockFilterUserKeys.RUnlock()
	return calls
}

// GetSessionUser calls GetSessionUserFunc.
func (mock *AuthProviderMock) GetSessionUser(ctx context.Context, token string) (string, bool) {
	if mock.GetSessionUserFunc == nil {
		panic("AuthProviderMock.GetSessionUserFunc: method is nil but AuthProvider.GetSessionUser was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockGetSessionUser.Lock()
	mock.calls.GetSessionUser = append(mock.calls.GetSessionUser, callInfo)
	mock.lockGetSessionUser.Unlock()
	return mock.GetSessionUserFunc(ctx, token)
}

// GetSessionUserCalls gets all the calls that were made to GetSessionUser.
// Check the length with:
//
//	len(mockedAuthProvider.GetSessionUserCalls())
func (mock *AuthProviderMock) GetSessionUserCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockGetSessionUser.RLock()
	calls = mock.calls.GetSessionUser
	mock.lockGetSessionUser.RUnlock()
	return calls
}

// InvalidateSession calls InvalidateSessionFunc.
func (mock *AuthProviderMock) InvalidateSession(ctx context.Context, token string) {
	if mock.InvalidateSessionFunc == nil {
		panic("AuthProviderMock.InvalidateSessionFunc: method is nil but AuthProvider.InvalidateSession was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockInvalidateSession.Lock()
	mock.calls.InvalidateSession = append(mock.calls.InvalidateSession, callInfo)
	mock.lockInvalidateSession.Unlock()
	mock.InvalidateSessionFunc(ctx, token)
}

// InvalidateSessionCalls gets all the calls that were made to InvalidateSession.
// Check the length with:
//
//	len(mockedAuthProvider.InvalidateSessionCalls())
func (mock *AuthProviderMock) InvalidateSessionCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockInvalidateSession.RLock()
	calls = mock.calls.InvalidateSession
	mock.lockInvalidateSession.RUnlock()
	return calls
}

// IsValidUser calls IsValidUserFunc.
func (mock *AuthProviderMock) IsValidUser(username string, password string) bool {
	if mock.IsValidUserFunc == nil {
		panic("AuthProviderMock.IsValidUserFunc: method is nil but AuthProvider.IsValidUser was just called")
	}
	callInfo := struct {
		Username string
		Password string
	}{
		Username: username,
		Password: password,
	}
	mock.lockIsValidUser.Lock()
	mock.calls.IsValidUser = append(mock.calls.IsValidUser, callInfo)
	mock.lockIsValidUser.Unlock()
	return mock.IsValidUserFunc(username, password)
}

// IsValidUserCalls gets all the calls that were made to IsValidUser.
// Check the length with:
//
//	len(mockedAuthProvider.IsValidUserCalls())
func (mock *AuthProviderMock) IsValidUserCalls() []struct {
	Username string
	Password string
} {
	var calls []struct {
		Username string
		Password string
	}
	mock.lockIsValidUser.RLock()
	calls = mock.calls.IsValidUser
	mock.lockIsValidUser.RUnlock()
	return calls
}

// LoginTTL calls LoginTTLFunc.
func (mock *AuthProviderMock) LoginTTL() time.Duration {
	if mock.LoginTTLFunc == nil {
		panic("AuthProviderMock.LoginTTLFunc: method is nil but AuthProvider.LoginTTL was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLoginTTL.Lock()
	mock.calls.LoginTTL = append(mock.calls.LoginTTL, callInfo)
	mock.lockLoginTTL.Unlock()
	return mock.LoginTTLFunc()
}

// LoginTTLCalls gets all the calls that were made to LoginTTL.
// Check the length with:
//
//	len(mockedAuthProvider.LoginTTLCalls())
func (mock *AuthProviderMock) LoginTTLCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLoginTTL.RLock()
	calls = mock.calls.LoginTTL
	mock.lockLoginTTL.RUnlock()
	return calls
}

// UserCanWrite calls UserCanWriteFunc.
func (mock *AuthProviderMock) UserCanWrite(username string) bool {
	if mock.UserCanWriteFunc == nil {
		panic("AuthProviderMock.UserCanWriteFunc: method is nil but AuthProvider.UserCanWrite was just called")
	}
	callInfo := struct {
		Username string
	}{
		Username: username,
	}
	mock.lockUserCanWrite.Lock()
	mock.calls.UserCanWrite = append(mock.calls.UserCanWrite, callInfo)
	mock.lockUserCanWrite.Unlock()
	return mock.UserCanWriteFunc(username)
}

// UserCanWriteCalls gets all the calls that were made to UserCanWrite.
// Check the length with:
//
//	len(mockedAuthProvider.UserCanWriteCalls())
func (mock *AuthProviderMock) UserCanWriteCalls() []struct {
	Username string
} {
	var calls []struct {
		Username string
	}
	mock.lockUserCanWrite.RLock()
	calls = mock.calls.UserCanWrite
	mock.lockUserCanWrite.RUnlock()
	return calls
}
